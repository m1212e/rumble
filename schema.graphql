schema {
	query: Query
	mutation: Mutation
	subscription: Subscription
}

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.This scalar is serialized to a string in ISO 8601 format and parsed from a string in ISO 8601 format.
"""
scalar DateTime

input DateWhereInputArgument {
	AND: [DateWhereInputArgument!]
	NOT: DateWhereInputArgument
	OR: [DateWhereInputArgument!]
	arrayContained: [Date!]
	arrayContains: [Date!]
	arrayOverlaps: [Date!]
	eq: Date
	gt: Date
	gte: Date
	ilike: String
	in: [Date!]
	isNotNull: Boolean
	isNull: Boolean
	like: String
	lt: Date
	lte: Date
	ne: Date
	notIlike: String
	notIn: [Date!]
	notLike: String
}

input FloatWhereInputArgument {
	AND: [FloatWhereInputArgument!]
	NOT: FloatWhereInputArgument
	OR: [FloatWhereInputArgument!]
	arrayContained: [Float!]
	arrayContains: [Float!]
	arrayOverlaps: [Float!]
	eq: Float
	gt: Float
	gte: Float
	ilike: String
	in: [Float!]
	isNotNull: Boolean
	isNull: Boolean
	like: String
	lt: Float
	lte: Float
	ne: Float
	notIlike: String
	notIn: [Float!]
	notLike: String
}

input IntWhereInputArgument {
	AND: [IntWhereInputArgument!]
	NOT: IntWhereInputArgument
	OR: [IntWhereInputArgument!]
	arrayContained: [Int!]
	arrayContains: [Int!]
	arrayOverlaps: [Int!]
	eq: Int
	gt: Int
	gte: Int
	ilike: String
	in: [Int!]
	isNotNull: Boolean
	isNull: Boolean
	like: String
	lt: Int
	lte: Int
	ne: Int
	notIlike: String
	notIn: [Int!]
	notLike: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

enum MoodenumEnum {
	happy
	ok
	sad
}

type Mutation {
	addUser(id: Int!, name: String!): User
	updateUsername(newName: String!, userId: Int!): User
}

type Post {
	author: User
	content: String!
	id: Int
}

input PostsOrderInputArgument {
	authorId: SortingParameter
	content: SortingParameter
	id: SortingParameter
}

input PostsWhereInputArgument {
	author: UsersWhereInputArgument
	authorId: IntWhereInputArgument
	content: StringWhereInputArgument
	id: IntWhereInputArgument
}

type Query {
	posts: [Post!]
	postsFiltered(where: PostsWhereInputArgument): [Post!]
	"""
	Get a single user by ID
	"""
	user(id: ID!): User!
	"""
	List all users
	"""
	users(
		limit: Int
		offset: Int
		orderBy: UsersOrderInputArgument
		where: UsersWhereInputArgument
	): [User!]!
}

enum SortingParameter {
	asc
	desc
}

input StringWhereInputArgument {
	AND: [StringWhereInputArgument!]
	NOT: StringWhereInputArgument
	OR: [StringWhereInputArgument!]
	arrayContained: [String!]
	arrayContains: [String!]
	arrayOverlaps: [String!]
	eq: String
	gt: String
	gte: String
	ilike: String
	in: [String!]
	isNotNull: Boolean
	isNull: Boolean
	like: String
	lt: String
	lte: String
	ne: String
	notIlike: String
	notIn: [String!]
	notLike: String
}

type Subscription {
	"""
	Get a single user by ID
	"""
	user(id: ID!): User!
	"""
	List all users
	"""
	users(
		limit: Int
		offset: Int
		orderBy: UsersOrderInputArgument
		where: UsersWhereInputArgument
	): [User!]!
}

type User {
	id: Int!
	moodcol: MoodenumEnum
	name: String!
	"""
	Get the posts related to this user
	"""
	posts(
		limit: Int
		offset: Int
		orderBy: PostsOrderInputArgument
		where: PostsWhereInputArgument
	): [Post!]!
	somethingElse(amount: Int!): String
}

input UsersOrderInputArgument {
	id: SortingParameter
	moodcol: SortingParameter
	name: SortingParameter
	posts: PostsOrderInputArgument
}

input UsersWhereInputArgument {
	id: IntWhereInputArgument
	moodcol: MoodenumEnum
	name: StringWhereInputArgument
	posts: PostsWhereInputArgument
}
